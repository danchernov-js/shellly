<!DOCTYPE html>
<html>
  <head>
    <title>!DOCTYPE</title>
    <meta charset="utf-8" />
    <link href="styles.css" rel="stylesheet"/>
  </head>

  <body>
    <div class="logo">
      She<span style="color: #fc615d">l</span>
      <span style="color: #fdbd41">l</span>
      <span style="color: #34c84a">l</span>y
    </div>
    <div class="browser-window">
      <div class="browser-window-header">
        <div class="browser-window-header-left">
          <span
            class="browser-window-header-left_circle-button circle-red"
          ></span>
          <span
            class="browser-window-header-left_circle-button circle-yellow"
          ></span>
          <span
            class="browser-window-header-left_circle-button circle-green"
          ></span>
        </div>
      </div>
      <div id="drop-area">
        <form class="my-form">
          <p>
            Загрузите изображения с помощью диалога выбора файлов или перетащив
            нужные изображения в выделенную область
          </p>
          <input
            type="file"
            id="inp"
            multiple 
            accept="image/*"
            onchange="handleFiles(this.files)"
          />
          <label class="button" for="inp"> Выбрать изображения </label>
        </form>
        <div id="card-container"></div>
      </div>
    </div>

    <div class="download-bar" id="download-bar"> <!-- кнопка загрузки результата -->
      <button id="download">Download</button>
    </div>
    <!-- упаковываем все картинки в зип файл -->
    <script src="/jszip-utils-master/dist/jszip-utils.js"></script>
    <script src="/jszip-master/dist/jszip.min.js"></script>
    <script src="/jszip-master/vendor/FileSaver.js"></script>
    <script>
      // при наведении файлом на область - сбрасываем стандартные события браузера, 
      // которые должны происходить при этом наведении, возможно лишнее
      window.ondragover = function(e) {e.preventDefault()} 
      //при сбросе (отпускании клавиши мыши) снова сбрасываем стандартное поведение браузера
      //чекнуть
      window.ondrop = function (e) {
        e.preventDefault();
        prepareFiles(e.dataTransfer.files);
      };
      //обработчик для инпута, разобраться как их у меня два оказалось
      document.getElementById("inp").onchange = function (e) {
        prepareFiles(this.files);
      };
      //слушаю событие вставить и обработчик, фолс еще чекнуть - можно удалить
      window.addEventListener(
        "paste",
        function (e) {
          prepareFiles(e.clipboardData.files);
        },
        false
      );

      let dropArea = document.getElementById("drop-area");

      ["dragenter", "dragover", "dragleave", "drop"].forEach((eventName) => {
        window.addEventListener(eventName, preventDefaults, false);
      });

      // Highlight drop area when item is dragged over it
      ["dragenter", "dragover"].forEach((eventName) => {
        window.addEventListener(eventName, highlight, false);
      });
      ["dragleave", "drop"].forEach((eventName) => {
        window.addEventListener(eventName, unhighlight, false);
      });

      function preventDefaults(e) {
        e.preventDefault();
        e.stopPropagation();
      }

      function highlight(e) {
        dropArea.classList.add("highlight");
      }

      function unhighlight(e) {
        dropArea.classList.remove("highlight");
      }

      const onlyimg = [];
      const imageArr = []; //собирается из тех же файлов, с исходными картинками, чтобы в дальнейшем
      //использовать в канвасе
      const imageDownArr = []; //собирается из файлов которые готовы к скачке (ссылка и имя)
      const sameName = []; //не используется по сути


     // чекнуть, должна складывать название и каунтер, вероятно можно удалить
      function collectSameNames(nameValue, matchCounter) {
        return {
          xname: nameValue,
          xnumber: matchCounter,
        };
      }

      function prepareFiles(files) {
        files = [...files];
        console.log(files);
        files.forEach(drawe);
        imageArr.forEach(renderer);
        imageArr.length = 0;
      }

      var i = 0; //уникальный айдишник для канвас для последующего взаимодействия
      var k = 1; //счетчик который приписывается для уникального названия

      //распихивает названия файла, айдишники, ссылки по массивам, сравния по названию, можно перензавать
      function drawe(file) {
        var img = new Image();
        if (imageDownArr.length == 0) {
          console.log("zero");
          imageArr.push(
            collectCanvasIdAndName(
              "canvas-id-" + i,
              URL.createObjectURL(file),
              file.name
            )
          );
          imageDownArr.push(
            collectCanvasIdAndName("canvas-id-" + i, "", file.name)
          );
        } else {
          //проверяем название без расширений на повтор
          let trueCheck = imageDownArr.find(
            (item) =>
              item.fname
                .substring(0, item.fname.lastIndexOf("."))
                .toLowerCase() ==
              file.name.substring(0, file.name.lastIndexOf(".")).toLowerCase()
          );
          //если не повторяется, то все ок - добавляем
          if (trueCheck == undefined) {
            imageArr.push(
              collectCanvasIdAndName(
                "canvas-id-" + i,
                URL.createObjectURL(file),
                file.name
              )
            );
            imageDownArr.push(
              collectCanvasIdAndName("canvas-id-" + i, "", file.name)
            );
          } else {
            //сеймнейм пока не работает, можно удалить
            sameName.push(
              collectSameNames(
                file.name
                  .substring(0, file.name.lastIndexOf("."))
                  .toLowerCase(),
                1
              )
            );
            //добавляем в название каунтер к, переделать
            imageArr.push(
              collectCanvasIdAndName(
                "canvas-id-" + i,
                URL.createObjectURL(file),
                file.name.substring(0, file.name.lastIndexOf(".")) +
                  ` (${k})` +
                  file.name.substring(file.name.lastIndexOf("."))
              )
            );
            imageDownArr.push(
              collectCanvasIdAndName(
                "canvas-id-" + i,
                URL.createObjectURL(file),
                file.name.substring(0, file.name.lastIndexOf(".")) +
                  ` (${k})` +
                  file.name.substring(file.name.lastIndexOf("."))
              )
            );
            k++;
            console.log(sameName);
          }
        }

        console.log(imageArr);
        i++;
      }

      renderer = function (item) {
        const gayDad = document.createElement("div");
        const gay = document.createElement("canvas");
        const boooy = document.createElement("p");
        gayDad.className = "card";
        boooy.className = "image-name";

        console.log(i, imageArr.length);
        gayDad.id = item.cid + "-wrap";
        gay.id = item.cid;

        document.getElementById("card-container").appendChild(gayDad);
        document.getElementById(gayDad.id).appendChild(boooy);
        boooy.innerHTML += item.fname;

        document.getElementById(gayDad.id).appendChild(gay);

        const gCanvas = document.getElementById(item.cid);
        const gCtx = gCanvas.getContext("2d");
        item.img = new Image();

        item.img.src = item.flink;

        console.log(item.img.src);

        item.img.onload = function () {
          console.log(i);

          //Variables
          var x = 20;
          var y = 10;
          var barH = 40;
          var borderR = 10;
          var circleOffsetX = 14;
          var circleR = 5;

          //Canvas size
          gCanvas.width = item.img.width + x * 2;
          gCanvas.height = item.img.height + y * 4 + barH;

          //Gradient example
          // var barGrd = gCtx.createLinearGradient(0, 0, 0, barH);
          // barGrd.addColorStop(0,"rgb(230,230,230)");
          // barGrd.addColorStop(1,"rgb(220,220,220)");
          // gCtx.fillStyle = barGrd;

          //Browser window shadow;
          gCtx.globalAlpha = 0.2;
          gCtx.shadowColor = "black";
          gCtx.shadowOffsetY = 10;
          gCtx.shadowBlur = 15;
          gCtx.fillStyle = "rgb(201,201,201)";
          roundRect(
            gCtx,
            x,
            y,
            this.width,
            this.height + barH,
            borderR,
            true,
            false
          );

          //Browser window;
          gCtx.globalAlpha = 1;
          gCtx.shadowOffsetY = 0;
          gCtx.shadowBlur = 0;
          gCtx.fillStyle = "rgb(201,201,201)";
          roundRect(
            gCtx,
            x,
            y,
            this.width,
            this.height + barH,
            borderR,
            true,
            false
          );

          //Browser bar
          gCtx.shadowOffsetY = 0;
          gCtx.shadowBlur = 0;
          gCtx.fillStyle = "rgb(255,255,255)";
          roundRect(
            gCtx,
            x,
            y,
            this.width,
            barH,
            { tl: borderR, tr: borderR },
            true,
            false
          );

          //Red circle
          gCtx.fillStyle = "rgb(223,72,69)";
          roundRect(
            gCtx,
            x + circleOffsetX + 20 * 0,
            y + circleOffsetX,
            12,
            12,
            circleR + 1,
            true,
            false
          );

          gCtx.fillStyle = "rgb(252,97,93)";
          roundRect(
            gCtx,
            x + circleOffsetX + 20 * 0 + 1,
            y + circleOffsetX + 1,
            12 - 2,
            12 - 2,
            circleR,
            true,
            false
          );

          //Yellow circle
          gCtx.fillStyle = "rgb(222,160,52)";
          roundRect(
            gCtx,
            x + circleOffsetX + 20 * 1,
            y + circleOffsetX,
            12,
            12,
            circleR + 1,
            true,
            false
          );

          gCtx.fillStyle = "rgb(253,189,65)";
          roundRect(
            gCtx,
            x + circleOffsetX + 20 * 1 + 1,
            y + circleOffsetX + 1,
            12 - 2,
            12 - 2,
            circleR,
            true,
            false
          );

          //Green circle
          gCtx.fillStyle = "rgb(40,171,53)";
          roundRect(
            gCtx,
            x + circleOffsetX + 20 * 2,
            y + circleOffsetX,
            12,
            12,
            circleR + 1,
            true,
            false
          );

          gCtx.fillStyle = "rgb(52,200,74)";
          roundRect(
            gCtx,
            x + circleOffsetX + 20 * 2 + 1,
            y + circleOffsetX + 1,
            12 - 2,
            12 - 2,
            circleR,
            true,
            false
          );

          //Browser search bar
          gCtx.fillStyle = "rgba(230,230,230,0.64)";
          roundRect(
            gCtx,
            x + 77,
            y + 7,
            gCanvas.width - x * 2 - 77 * 2,
            24,
            circleR + 1,
            true,
            false
          );

          //Browser address
          gCtx.fillStyle = "rgb(110,110,110)";
          gCtx.strokeStyle = "rgba(0,0,0,0)";
          gCtx.font = "14px Arial";
          gCtx.fillText("bronevik.com", this.width / 2 - 42, barH - 6);

          //Image mask
          gCtx.beginPath();
          roundRect(
            gCtx,
            x,
            y + barH,
            this.width,
            this.height,
            { bl: borderR, br: borderR },
            true,
            false
          );
          gCtx.clip();
          // /// draw the shape we want to use for clipping
          // roundRect.drawImage(gCtx, 10, 60, this.width, this.height, {bl: 20, br: 20}, true, false);
          // /// change composite mode to use that shape
          // gCtx.globalCompositeOperation = 'source-in';
          //
          // /// draw the image to be clipped
          // gCtx.drawImage(this, 10,60);
          // roundRect(gCtx.drawImage, 10, 60, this.width, this.height, {bl: 20, br: 20}, true, false);
          gCtx.drawImage(item.img, x, y + barH);
          gCtx.strokeStyle = "rgb(201,201,201)";
          roundRect(
            gCtx,
            x,
            y + barH - 1,
            this.width,
            this.height + 1,
            { bl: borderR, br: borderR },
            false,
            true
          );
        };

        const downBar = document.getElementById("download-bar");
        downBar.classList.add("download-bar-highlight");
      };

      function collectCanvasId(canvasId, fileLink) {
        return {
          cid: canvasId,
          flink: fileLink,
        };
      }

      function collectCanvasIdAndName(canvasId, fileLink, fileName) {
        return {
          cid: canvasId,
          flink: fileLink,
          fname: fileName,
        };
      }

      function roundRect(ctx, x, y, width, height, radius, fill, stroke) {
        if (typeof stroke === "undefined") {
          stroke = true;
        }
        if (typeof radius === "undefined") {
          radius = 5;
        }
        if (typeof radius === "number") {
          radius = { tl: radius, tr: radius, br: radius, bl: radius };
        } else {
          var defaultRadius = { tl: 0, tr: 0, br: 0, bl: 0 };
          for (var side in defaultRadius) {
            radius[side] = radius[side] || defaultRadius[side];
          }
        }
        ctx.beginPath();
        ctx.moveTo(x + radius.tl, y);
        ctx.lineTo(x + width - radius.tr, y);
        ctx.quadraticCurveTo(x + width, y, x + width, y + radius.tr);
        ctx.lineTo(x + width, y + height - radius.br);
        ctx.quadraticCurveTo(
          x + width,
          y + height,
          x + width - radius.br,
          y + height
        );
        ctx.lineTo(x + radius.bl, y + height);
        ctx.quadraticCurveTo(x, y + height, x, y + height - radius.bl);
        ctx.lineTo(x, y + radius.tl);
        ctx.quadraticCurveTo(x, y, x + radius.tl, y);
        ctx.closePath();
        if (fill) {
          ctx.fill();
        }
        if (stroke) {
          ctx.stroke();
        }
      }

      function draw() {}
      function failed() {
        console.error("The provided file couldn't be loaded as an Image media");
      }

      function onSave() {
        var downloadProgress = document.getElementById("download");
        downloadProgress.disabled = true;
        downloadProgress.innerHTML = "downloading...";

        imageDownArr.forEach(function (item) {
          const gCanvas = document.getElementById(item.cid);
          const gCtx = gCanvas.getContext("2d");
          gCanvas.toBlob((blob) => {
            const timestamp = Date.now().toString();
            const a = document.createElement("a");
            document.body.append(a);
            a.download =
              "export-" + item.fname.substring(0, item.fname.lastIndexOf("."));
            console.log(a.download);
            a.href = URL.createObjectURL(blob);
            console.log(a.href);
            item.flink = a.href;
            onlyimg.push(item.flink);
            console.log(item.flink);

            if (imageDownArr.length > 1) {
              // var JSZip = require("jszip-sync");
              var zip = new JSZip();
              var count = 0;
              // onlyimg.forEach(function (item) {
              //           JSZipUtils.getBinaryContent(item, function (err, data) {
              //                   zip.sync(function() {
              //                       zip.file('export-'+imageDownArr[count].fname.substring(0, imageDownArr[count].fname.lastIndexOf('.'))+'.png', data, { binary: true });
              //                       count++;
              //                       zip.generateAsync({type: "arraybuffer", compression: "DEFLATE"})
              //                           .then(function(content) {
              //                             saveAs(content, `macshell-${timestamp}.zip`);
              //                             count = 0;
              //                             onlyimg.length = 0;
              //                               });
              //                   });
              //           });
              //       });

              // var zipped = zip.sync(function() {
              //     // put some stuff in there
              //     zip.file("Hello.txt", "Hello World\n");
              //     var img = zip.folder("images");
              //     img.file("smile.gif", imgData, {base64: true});
              //     // call regular async methods
              //     var data = null;
              //     zip.generateAsync({type: "arraybuffer", compression: "DEFLATE"})
              //         .then(function(content) {
              //             data = content;
              //             });
              //     return data;
              // });
              //
              var zip = new JSZip();
              var count = 0;

              onlyimg.forEach(function (item) {
                JSZipUtils.getBinaryContent(item, function (err, data) {
                  zip.file(
                    "export-" +
                      imageDownArr[count].fname.substring(
                        0,
                        imageDownArr[count].fname.lastIndexOf(".")
                      ) +
                      ".png",
                    data,
                    { binary: true }
                  );
                  downloadProgress.style.background =
                    "linear-gradient(to right, #0f0 " +
                    (100 / imageDownArr.length) * (count + 1) +
                    "%, #eee " +
                    (100 / imageDownArr.length) * (count + 1) +
                    "%)";
                  count++;
                  if (count == imageDownArr.length) {
                    zip
                      .generateAsync({ type: "blob" })
                      .then(function (content) {
                        saveAs(content, `macshell-${timestamp}.zip`);
                        count = 0;
                        onlyimg.length = 0;
                        downloadProgress.style.background = "#ff0000";
                        downloadProgress.innerHTML = "download";
                        downloadProgress.disabled = false;
                      });
                    // async function doMagic() {
                    //   let blob = await zip.generateAsync({type: blob()});
                    //   saveAs(blob, `macshell-${timestamp}.zip`);
                    //   count = 0;
                    //   onlyimg.length = 0;
                    // }
                  }
                });
              });

              console.log("stop");
            } else {
              a.click();
            }
            a.remove();
          });
        });
      }

      document.querySelector("#download").addEventListener("click", onSave);
    </script>
  </body>
</html>
